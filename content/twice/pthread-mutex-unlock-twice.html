---
title: "The Best Pthread_Mutex_Unlock Twice References"
description: "Pthread_mutex_unlock unlocks the given mutex. To enable thread fn1 to lock the mutex first, the sleep function is called in fn2 to sleep fn2 for one second, so fn1 can lock the mutex first."
date: "2022-06-25"
categories:
  - "TWICE"
images: 
  - "https://i2.wp.com/i.imgur.com/mk5tlsx.jpg"
featuredImage: "https://tse1.mm.bing.net/th?q=pthread_mutex_unlock%20twice"
featured_image: "https://tse1.mm.bing.net/th?q=pthread_mutex_unlock%20twice"
image: "https://i2.wp.com/i.imgur.com/mk5tlsx.jpg"
---

<article>
    <p><strong>The Best Pthread_Mutex_Unlock Twice References</strong>. The pthread_mutex_destroy() function shall destroy the mutex object referenced by mutex; The default posix behavior doesn&#039;t allow recursive mutexes, and returns edeadlk.</p>
        <figure>
        <noscript>
            <img src="https://i.imgur.com/mk5tlsx.jpg" alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" width="640" height="360" />
        </noscript>
        <img class="v-cover ads-img" src="https://i.imgur.com/mk5tlsx.jpg" alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <figcaption>20170322 [學習筆記] 關於用 Pthread 取質數的問題 from shouzo.github.io</figcaption>
    </figure>
        <p>The default posix behavior doesn&#039;t allow recursive mutexes, and returns edeadlk. If there are threads blocked on the mutex object referenced by mutex when pthread_mutex_unlock () is called, resulting in the mutex becoming available, the scheduling policy shall determine which. The mutex should be owned by the calling thread.</p>
</article>
<!--more-->
<section>
    <aside>
        <img alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" src="https://i.imgur.com/arQk9zI.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.imgur.com/arQk9zI.jpg" >Download Image</a></p>
		<small>Source: <i>shouzo.github.io</i></small>
        <p>The manner in which a mutex is released is dependent. This type of mutex must be unlocked the same number to times it is locked before the mutex will be returned to an unlocked state.</p>
    </aside>
    <aside>
        <img alt="TFIDF 2017_07_27_11_49_43 d58444e HEAD{0} commit tmp 5c585e3 HEAD{1} merge tfidfreadfile" src="https://i.pinimg.com/originals/5a/a6/c6/5aa6c62bdaba05aa983d7ec73617fce6.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.pinimg.com/originals/5a/a6/c6/5aa6c62bdaba05aa983d7ec73617fce6.jpg" >Download Image</a></p>
		<small>Source: <i>www.pinterest.com</i></small>
        <p>This type of mutex must be unlocked the same number to times it is locked before the mutex will be returned to an unlocked state. [ xsi ] the manner in which a mutex is released is dependent upon the mutex&#039;s type attribute.</p>
    </aside>
    <aside>
        <img alt="《操作系统》实验3进程同步 王子泰" src="http://wang22ti.com/2018/04/20/《操作系统》实验3-进程同步/image6.png" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="http://wang22ti.com/2018/04/20/《操作系统》实验3-进程同步/image6.png" >Download Image</a></p>
		<small>Source: <i>wang22ti.com</i></small>
        <p>This kind of mutex can be created by assigning the constant pthread_recursive_mutex_initializer_np to a mutex variable. If there are threads blocked on the mutex object when pthread_mutex_unlock() is called, resulting in the mutex becoming available, the scheduling policy is used to determine which thread acquires the mutex.</p>
    </aside>
    <aside>
        <img alt="20170324 [學習筆記] Linux 系統程式 (4)" src="https://i.imgur.com/jw2pSxj.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.imgur.com/jw2pSxj.jpg" >Download Image</a></p>
		<small>Source: <i>shouzo.github.io</i></small>
        <p>Create two threads in the main function, fn1 in thread 1, lock mutex twice, but unlock only once.thread fn2 cannot lock the mutex, causing it to remain blocked at position 1. You won’t be able to take ownership with the second unique_lock.</p>
    </aside>
    <aside>
        <img alt="四十三、Linux 线程——线程同步之线程信号量 游戏进行中 博客园" src="https://img2018.cnblogs.com/blog/1142140/201901/1142140-20190114210541668-1091951013.png" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://img2018.cnblogs.com/blog/1142140/201901/1142140-20190114210541668-1091951013.png" >Download Image</a></p>
		<small>Source: <i>www.cnblogs.com</i></small>
        <p>You’ll see some errors there. What&#039;s the best way to avoid locking a mutex twice?</p>
    </aside>
    <aside>
        <img alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" src="https://i.imgur.com/CGXHTue.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.imgur.com/CGXHTue.jpg" >Download Image</a></p>
		<small>Source: <i>shouzo.github.io</i></small>
        <p>The mutex is assumed to be locked and owned by the calling thread on entrance to pthread_mutex_unlock. Int pthread_mutex_unlock(pthread_mutex_t *mutex);int pthread_mutex_destroy(pthread_mutex_t *mutex);</p>
    </aside>
    <aside>
        <img alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" src="https://i.imgur.com/mk5tlsx.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.imgur.com/mk5tlsx.jpg" >Download Image</a></p>
		<small>Source: <i>shouzo.github.io</i></small>
        <p>The first function above releases the lock and the second function destroys the lock so that it cannot be used anywhere in future. That is, a thread attempting to relock this mutex without first unlocking will succeed.</p>
    </aside>
    <aside>
        <img alt="20170322 [學習筆記] 關於用 Pthread 取質數的問題" src="https://i.imgur.com/HeJEnU0.jpg" width="100%" style="margin-right: 8px;margin-bottom: 8px;" />
        <p align="center"><a rel="nofollow" target="_blank" href="https://i.imgur.com/HeJEnU0.jpg" >Download Image</a></p>
		<small>Source: <i>shouzo.github.io</i></small>
        <p>These are the top rated real world c++ (cpp) examples of pthread_mutex_trylock extracted from open source projects. Pthread_mutex_unlock unlocks the given mutex.</p>
    </aside>
</section>
<section>
        <h3>If There Are Threads Blocked On The Mutex Object Referenced By Mutex When Pthread_Mutex_Unlock () Is Called, Resulting In The Mutex Becoming Available, The Scheduling Policy Shall Determine Which.</h3>
    <br/>
    <p>If the mutex type is pthread_mutex_recursive and the mutex is currently owned by the calling thread, the mutex lock count shall be incremented by one and the pthread_mutex_trylock() function shall immediately return success. Locking and unlocking a mutex The pthread_mutex_trylock () function is identical to pthread_mutex_lock () except that if the mutex object referenced by mutex is currently locked (by any thread, including the current thread), the call fails immediately with ebusy.</p>
        <h3>The Pthread_Mutex_Unlock() Function Shall Release The Mutex Object Referenced By Mutex.</h3>
    <br/>
    <p>I have two functions that need to remain separate (and keep the same signature), and both need to be locked as they are called separately. A destroyed mutex object can be reinitialized using pthread_mutex_init(); In my main loop, i can not use mosquitto_loop_forever(), because it is a block function, my main loop looks more like :</p>
        <h3>The Mutex Should Be Owned By The Calling Thread.</h3>
    <br/>
    <p>A recursive type mutex permits a thread to lock many times. This type of mutex must be unlocked the same number to times it is locked before the mutex will be returned to an unlocked state. @ralight thanks, at first, i&#039;m sorry that there is something i havn&#039;t put the case clearly.</p>
        <h3>Pthread_Mutex_Unlock Unlocks The Given Mutex.</h3>
    <br/>
    <p>The mutex is assumed to be locked and owned by the calling thread on entrance to pthread_mutex_unlock. To enable thread fn1 to lock the mutex first, the sleep function is called in fn2 to sleep fn2 for one second, so fn1 can lock the mutex first. If there are threads blocked on the mutex object when pthread_mutex_unlock() is called, resulting in the mutex becoming available, the scheduling policy is used to determine which thread acquires the mutex.</p>
        <h3>That Is, A Thread Attempting To Relock This Mutex Without First Unlocking Will Succeed.</h3>
    <br/>
    <p>Create two threads in the main function, fn1 in thread 1, lock mutex twice, but unlock only once.thread fn2 cannot lock the mutex, causing it to remain blocked at position 1. If the mutex is of the ``fast&#039;&#039; kind, pthread_mutex_unlock always returns it to the unlocked state. The pthread_mutex_destroy () function shall destroy the mutex object referenced by mutex;</p>
</section>
